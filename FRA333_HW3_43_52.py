# file สำหรับเขียนคำตอบ
# ในกรณีที่มีการสร้าง function อื่น ๆ ให้ระบุว่า input-output คืออะไรด้วย
"""
ชื่อ_รหัส
1.พสุรัตน์ พิบูลย์จิรชาติ 65340500043
2.วิจักขณ์ มะโนปราง  65340500052
"""
import numpy as np
from HW3_utils import FKHW3  # import function FKHW3 ที่อยู่ในไฟล์ HW3_utils


# =============================================<คำตอบข้อ 1>======================================================#
def endEffectorJacobianHW3(q: list[float]) -> list[float]:
    # ดึงเมทริกซ์การแปลง (R, R_e) และจุดตำแหน่ง (P, p_e) จากฟังก์ชัน Forward Kinematics
    R, P, R_e, p_e = FKHW3(q)

    # สร้างเมทริกซ์ 3x3 สำหรับ Jacobian ของความเร็วเชิงเส้น (J_v) และความเร็วเชิงมุม (J_w)
    J_v = np.zeros((3, 3))  # J_v จะเก็บความเร็วเชิงเส้น (linear velocity)
    J_w = np.zeros((3, 3))  # J_w จะเก็บความเร็วเชิงมุม (angular velocity)

    # สร้างเวกเตอร์แกน z ในเฟรมฐาน (Base frame) ซึ่งข้อต่อหมุนรอบแกน z ในเฟรมฐานคือ [0, 0, 1]
    z_0 = np.array([0, 0, 1])

    # วนลูปสำหรับข้อต่อแต่ละข้อ (มี 3 ข้อ) เพื่อคำนวณค่า Jacobian
    for i in range(3):
        # คำนวณแกน z_i ของข้อต่อที่ i ในเฟรมฐาน โดยใช้เมทริกซ์การหมุน R ที่ได้จาก FK
        z_i = (
            R[:, :, i] @ z_0
        )  # ใช้การคูณเมทริกซ์หมุน R ของข้อต่อ i กับแกน z_0 เพื่อหาทิศทางของแกนหมุนในระบบพิกัดฐาน

        # คำนวณ Jacobian ของความเร็วเชิงเส้น J_v สำหรับข้อต่อที่ i
        # โดยใช้ cross product ระหว่างแกนหมุน z_i และตำแหน่งของ end-effector ลบด้วยตำแหน่งของข้อต่อที่ i
        J_v[:, i] = np.cross(z_i, p_e - P[:, i])

        # คำนวณ Jacobian ของความเร็วเชิงมุม J_w สำหรับข้อต่อที่ i
        # โดยค่า J_w จะเป็นทิศทางของแกนหมุน z_i เอง (เพราะเป็นข้อต่อหมุน revolute joint)
        J_w[:, i] = z_i

    # นำ Jacobian ของความเร็วเชิงเส้น (J_v) และความเร็วเชิงมุม (J_w) มาต่อกันในแนวตั้ง
    # โดยได้เป็นเมทริกซ์ 6x3 ซึ่งเก็บข้อมูลของทั้งความเร็วเชิงเส้นและเชิงมุม
    J_e = np.vstack((J_v, J_w))

    # ส่งคืนค่า Jacobian J_e ซึ่งเป็นเมทริกซ์ขนาด 6x3 (ในรูปแบบลิสต์ของ float)
    return J_e


# ==============================================================================================================#


# =============================================<คำตอบข้อ 2>======================================================#
def checkSingularityHW3(q: list[float]) -> int:
    # กำหนดค่า threshold ที่ใช้บอกว่า determinant ใกล้ศูนย์แค่ไหนถึงจะถือว่ามี Singularity
    threshold = 0.001

    # เรียกฟังก์ชัน endEffectorJacobianHW3 เพื่อคำนวณ Jacobian matrix ของหุ่นยนต์ที่ตำแหน่ง q
    J_e = endEffectorJacobianHW3(q)

    # ดึงส่วนของเมทริกซ์ Jacobian ที่เกี่ยวกับตำแหน่ง (ส่วนความเร็วเชิงเส้น 3x3)
    J_v = J_e[:3, :3]

    # คำนวณค่า determinant ของเมทริกซ์ J_v ที่ได้ (เพราะถ้า determinant เป็นศูนย์ จะบอกได้ว่ามี Singularity)
    det_J_v = np.linalg.det(J_v)

    # ตรวจสอบว่าค่า determinant ใกล้เคียงกับศูนย์หรือไม่ ถ้าใช่ แสดงว่ามี Singularity
    if abs(det_J_v) < threshold:
        return 1  # ถ้าใช่, บอกว่าเกิด Singularity
    else:
        return 0  # ถ้าไม่ใช่, ไม่มี Singularity


# ==============================================================================================================#


# =============================================<คำตอบข้อ 3>======================================================#
def computeEffortHW3(q: list[float], w: list[float]) -> list[float]:
    # แปลงค่า w ที่เป็นลิสต์ให้เป็น numpy array เพื่อให้จัดการง่ายขึ้น
    wrench = np.array(w)

    # คำนวณ Jacobian matrix โดยใช้ฟังก์ชันที่เราเขียนไว้ก่อนหน้า endEffectorJacobianHW3
    # ฟังก์ชันนี้จะคำนวณเมทริกซ์ J_e ที่แสดงความสัมพันธ์ระหว่างการหมุนของข้อต่อกับการเคลื่อนที่ของ end-effector
    J_e = endEffectorJacobianHW3(q)

    # คำนวณค่าแรงบิด (torque หรือ effort) สำหรับแต่ละข้อต่อโดยใช้สูตร: tau = J^T * wrench
    # J^T คือการ transpose ของ Jacobian (เปลี่ยนแถวเป็นคอลัมน์)
    # wrench คือแรงและโมเมนต์ที่ได้จากเซนเซอร์
    tau = J_e.T @ wrench

    # ส่งคืนค่า torque หรือ effort ที่ได้เป็นลิสต์ของ float
    return tau.tolist()


# ==============================================================================================================#
